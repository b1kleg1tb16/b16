<h5>About</h5>

<p>
<img id="DanBikle" alt="Dan_Bikle" src="http://bornboulder77.googlepages.com/DanBikle2006_09_7.jpg" height="300" width="400">
</p>

<p>
In June of 1988 Dan Bikle graduated from Caltech with a BSEE.
</p><p>

</p><p>
A year before that he had started working at Oracle Corporation as an engineer.
</p><p>

A year after graduation, he left Oracle and started a consulting
business to help early adopter customers implement ERP systems based
on both Oracle Financials and Oracle Manufacturing which were both new
and immature products.  It was a perfect time to start that consulting
business.
</p><p>

During the 1990s Dan worked at a wide variety of clients in the Bay
Area who needed help migrating off of legacy systems (such as ManMan)
to Oracle Applications.
</p><p>

In 1998 Dan started taking on clients who were building large
database backed websites such as Lycos' MailCity.
</p><p>

The web started to dominate Dan's consulting business.  In 2001 he
finished his last Oracle Applications engagement and focused on
database backed websites.
</p><p>

In 2003 Dan took on a full time job in the Sun IForce lab to connect
with engineers and early adopter customers who wanted to use low-cost
hardware to build clustered Oracle databases to back large websites.
The timing was good.  Oracle Corporation delivered cache-fusion in
Oracle 9i (and enhanced in 10g) which made horizontal scalability
possible in the database tier of an application.
</p><p>
Another big event
was delivery of the low-cost 64 bit Opteron CPU from AMD.  Clustered
databases powered by low cost Opteron systems offered serious
competition to expensive, vertically scaled machines from Sun, IBM,
and HP.  In 2005 Dan left Sun to take advantage of that opportunity.
</p><p>

Also in 2005, a large change was delivered to the world of
web application development: Ruby on Rails (RoR).
</p><p>

Before RoR, Java based systems were the only good option available
to an implementor of a large database backed website.
</p><p>

RoR hits the sweet spot of the constraint-configurabilty-tradeoff.
</p><p>

Because of this Dan has dedicated most of his recent efforts to
building RoR based websites.
</p><p>

The RoR sweet spot is so sweet that a moderately proficient programmer
can build a large feature rich database backed website by himself in 3
to 6 months.
</p><p>

This means that all of the communication and training based overhead
associated with an equivalent team writing a Java based website can be
swept aside.
</p><p>

RoR can deliver enormous development savings because all project based
communication can reside in one developer's mind.
</p><p>

If you need to build a large database backed website, and you are
willing to try RoR instead of J2EE, Dan can help.
</p><p>

Also, RoR can be deployed in a modular way.  A legacy site can be migrated
to RoR bit-by-bit while the two applications run simultaneously.
</p><p>

The end-user would see just one site while this is happening.
</p><p>

RoR plays well with Java.  In fact you can run Java Classes inside
of Ruby and vice-versa using JRuby.
</p><p>

Dan's methodology to building a large site is simple:
</p><p>

1. Obtain / Derive a list of functions the site will deliver

</p><p>

2. Obtain / Derive a list of Model classes for the application
  (Typically these are nouns which jump out from function descriptions)
</p><p>

3. Decide how the Model classes are related
   (One-Many, Many-Many, One-One)
</p><p>

4. Look for Data Structures in Models (Tree, Nested Set, List)
</p><p>

5. Code up the model classes
</p><p>

6. Code up the physical database structure and then run that code
</p><p>

7. Fill up the database with fixture data so the developer can "see" it
</p><p>

8. Build a web1.0 prototype which looks something like Craigslist
   (Also you could get a jump-start on step 12 here)
</p><p>

9. Iterate with the users over the prototype
</p><p>

10. Drape a pretty skin over the prototype and stop calling it a prototype
</p><p>

11. Iterate with the users over the site
</p><p>

12. Code up unit tests, functional tests, integration tests, and load tests.
</p><p>

13. Leverage off the testing code to setup monitoring
</p><p>

14. Swap out the development database with a clustered database infrastructure
</p><p>

15. Deploy the RoR code to a production infrastructure
</p><p>

16. Turn on monitoring, production level backups, and disaster recovery mechanisms
</p><p>

17. Run all the tests written in step 12.
</p><p>

18. Fix bottlenecks found by load tests.

</p><p>

19. Test disaster recovery
</p><p>

20. Go Live!

</p>
